/**
 * Generates ORM models based on provided database schema.
 * At the moment, only supporting Postgresql and Sequelize ORM.
 * 
 * Internally, this script will fetch all tables names using the db configuration 
 * set in src/config/main.js and will generate a new model in src/models for each.
 * 
 * @todo    Obtain foreign indexes and generate appropiate "model association" source code.
 * 
 * ATTENTION! This will overwrite existing models.
 * 
 * @author Nicolas Iglesias <nicolas@clevertech.biz>
 */

var fs = require('fs')
,pg=require('pg')
,path = require('path')
,inflector = require('inflector')
,seq = require('sequelize')
,config = require(path.resolve(__dirname+'/../../src/config/main'))
,modelName = null;

if(process.argv[2]){
    modelName = process.argv[2].trim().singular();
}

var con = 'tcp://'
+config.main.db.username
+':'
+config.main.db.password
+'@'
+config.main.db.host
+'/'
+config.main.db.database;

var typeMap = {
    varchar:'string',
    text:'text',
    'int':'integer',
    'integer':'integer',
    timestamp:'date',
    date:'date',
    bool:'boolean',
    tinyint:'integer',
    numeric:'float',
    'float':'float',
    'double':'float'
}

var client = new pg.Client(con);
client.connect(function(err) {
    var qc, qt = null;
    
    switch(config.main.db.driver){
        case 'postgres':
            qt = "select * from information_schema.tables as t where t.table_catalog = '"
            +config.main.db.database+"' "
            +"and t.table_schema = 'public'";
            qc = "\
SELECT c.relname as table, a.attnum, a.attname AS field, t.typname AS type, \
    a.attlen AS length, a.atttypmod AS length_var, \
    a.attnotnull AS not_null, a.atthasdef as has_default \
FROM pg_class c, pg_attribute a, pg_type t \
WHERE c.relname = '$$table' \
  AND a.attnum > 0 \
  AND a.attrelid = c.oid \
  AND a.atttypid = t.oid \
ORDER BY a.attnum;\
";
            break;
    }
    
    // get tables list
    var tables = []
    var qtt = client.query(qt);
    qtt.on('row',function(r){
        var o = {};
        o.fileHeader ="\
/**\n\
 * "+r.table_name.singular().humanize()+" model.\n\
 *\n\
 * Auto-generated by modelGenerator.\n\
 *\n\
 * @author Nicolas Iglesias <nicolas@clevertech.biz>\n\
 */\n\
";
        o.fileHeader += "\
var inflector = require('inflector');\n\
\n\
exports.model = {\
";
        o.fileBody = '';
        o.queryColumns = qc.replace(/\$\$table/gi,r.table_name);
        o.fileFooter = '}';
        tables[r.table_name] = o;
    });
    qtt.on('end',function(){
        for(var t in tables){
            if(modelName!== null && modelName !== t.singular()) continue;
            
            var qqc = client.query(tables[t].queryColumns);
            qqc.on('row',function(c){
                if(typeof tables[c.table].columns === 'undefined')
                    tables[c.table].columns = [];
                tables[c.table].columns.push(c);
            });
            qqc.on('end',function(){
                });
        }
        
        setTimeout(function(){
            client.end();
            
            for(tt in tables){
                if(modelName!== null && modelName !== tt.singular()) continue;
                
                tables[tt].fileBody = "\t// access your variables by adding the $$ prefix\n";
                tables[tt].fileBody += "\tname : '"+tt.singular()+"',\n";
                tables[tt].fileBody += "\t// map your database columns here\n\tfields : [\n";
                tables[tt].columns.forEach(function(c){
                    var type = /int\d+/.test(c.type) ? typeMap['int'] : typeMap[c.type];
                    var props = [
                    'name : \''+c.field+'\'',
                    'label : \''+c.field+'\'.humanize()',
                    'type : \''+type+'\'',
                    'required : '+(!c.not_null?'false':'true')
                    ];
                    
                    if(type === typeMap['int'] && c.field === 'id')
                        props.push('primaryKey : true');
                    if(c.length_var!==-1)
                        props.push('max : '+(config.main.db.driver==='postgres'?c.length_var-4:c.length_var)); // postgres adds 4 chars
                    
                    tables[tt].fileBody += '\t\t{'+props.join(', ')+'},\n';
                });
                tables[tt].fileBody += '\t],\n'
                tables[tt].fileBody += ''
                +'\t// place your custom model methods below.\n'
                +'\tmethods : {\n'
                +"\t\t$instanceMethod : function(){ console.log('Prefix your instance methods\\' name with a dollar sign ($). Example: model.$instanceMethod()');},\n"
                +"\t\tclassMethod : function(){ console.log('This class method is accesed statically. Example: this.$$.models.modelName.classMethod()');}\n"
                +'\t},\n'
                +'\trelations : {\n'
                +'\t\thasOne:[],\n'
                +'\t\thasMany:[],\n'
                +'\t\tbelongsTo:[],\n'
                +'\t}';
                
                var content = [
                tables[tt].fileHeader,
                tables[tt].fileBody,
                tables[tt].fileFooter
                ];
                var fname = path.resolve(__dirname+'/../../src/models/'+tt.singular().toLowerCase()+'.js');

                console.log('Saving '+tt.singular()+' model into '+fname);
                fs.writeFile(fname,content.join('\n'),function(err){
                    if (err) throw err;
                });
            }
        }, 5000);
    });
});