/**
 * Generates daturajs models based on provided database schema.
 * At the moment, only supporting Postgresql and Sequelize ORM.
 * 
 * Internally, this script will fetch all tables names using the db configuration 
 * set in src/config/main.js and will generate a new model in src/models for each.
 * 
 * @todo    Obtain foreign indexes and generate appropiate "model association" source code.
 * 
 * ATTENTION! This will overwrite existing models.
 * 
 * @author Nicolas Iglesias <nico@webpolis.com.ar>
 */

var fs = require('fs')
,pg=require('pg')
,mysql=require('mysql')
,path = require('path')
,inflector = require('inflector')
,seq = require('sequelize')
,config = require(path.resolve(__dirname+'/../../src/config/main'))
,modelName = null, tables = [];

if(process.argv[2]){
    modelName = process.argv[2].trim().singular();
}

// define type mapping
var typeMap = {
    varchar:'string',
    'char':'string',
    text:'text',
    'int':'integer',
    'integer':'integer',
    timestamp:'date',
    date:'date',
    datetime:'date',
    bool:'boolean',
    tinyint:'integer',
    numeric:'float',
    'float':'float',
    'double':'float'
}

// set queries and custom connection startup
var con, client, qc, qt = null;
switch(config.main.db.driver){
    case 'postgres':
        con = 'tcp://'
            +config.main.db.username
            +':'
            +config.main.db.password
            +'@'
            +config.main.db.host
            +'/'
            +config.main.db.database;
        client = new pg.Client(con);
        
        // query for retrieving tables list
        qt = "select * from information_schema.tables as t where t.table_catalog = '"
            +config.main.db.database+"' "
            +"and t.table_schema = 'public'";
        // query for retrieving columns info
        qc = "\
SELECT c.relname as Table, a.attnum, a.attname AS Field, t.typname AS Type, \
    a.attlen AS Length, a.atttypmod AS length_var, \
    a.attnotnull AS Null, a.atthasdef as has_default \
FROM pg_class c, pg_attribute a, pg_type t \
WHERE c.relname = '$$table' \
  AND a.attnum > 0 \
  AND a.attrelid = c.oid \
  AND a.atttypid = t.oid \
ORDER BY a.attnum;\
";
        break;
    case 'mysql':
        client = mysql.createConnection({
            host:config.main.db.host,
            user:config.main.db.username,
            password:config.main.db.password,
            database:config.main.db.database,
            port:config.main.db.port
        });
        qt = 'SHOW TABLES FROM '+config.main.db.database;
        qc = 'SHOW FULL COLUMNS FROM $$table FROM '+config.main.db.database;
        break;
}

// retrieve table names
var fnTables = function(r){
    var tableName, queryCols, o = {};
    
    switch(config.main.db.driver){
        case 'postgres':
            tableName = r.table_name;
            break;
        case 'mysql':
            tableName = r['Tables_in_'+config.main.db.database];
            break;
    }
    
    queryCols = qc.replace(/\$\$table/gi,tableName);
    o.fileHeader ="\
/**\n\
 * "+tableName.singular().humanize()+" model.\n\
 *\n\
 * Auto-generated by modelGenerator.\n\
 *\n\
 * @author Nicolas Iglesias <nico@webpolis.com.ar>\n\
 */\n\
";
    o.fileHeader += "\
var inflector = require('inflector');\n\
\n\
exports.model = {\
";
    o.fileBody = '';
    o.queryColumns = queryCols;
    o.fileFooter = '}';
    tables[tableName] = o;
}

client.connect(function(err) {
    if(err) throw new Error(err).stack;
    
    // get tables list
    var evRow= null;
    var qtt = client.query(qt);
    
    switch(config.main.db.driver){
        case 'postgres':
            evRow = 'row';
            break;
        case 'mysql':
            evRow = 'result';
            break;
    }
    
    qtt.on(evRow,fnTables);
    qtt.on('end',function(){
        for(var t in tables){
            if(modelName!== null && modelName !== t.singular()) continue;
            
            var qqc = client.query(tables[t].queryColumns);
            qqc.on(evRow,function(c,d){
                var tt = null;
                switch(config.main.db.driver){
                    case 'postgres':
                        tt = c.table;
                        break;
                    case 'mysql':
                        tt = this.sql.replace(/^.*columns from ([^\s]+).*$/gi,'$1');
                        break;
                }
                if(typeof tables[tt].columns === 'undefined')
                    tables[tt].columns = [];
                tables[tt].columns.push(c);
            });
            qqc.on('end',function(){
                });
        }
        
        setTimeout(function(){
            client.end();
            
            for(tt in tables){
                if(modelName!== null && modelName !== tt.singular()) continue;
                
                tables[tt].fileBody = "\t// access your variables by adding the $$ prefix\n";
                tables[tt].fileBody += "\tname : '"+tt.singular()+"',\n";
                tables[tt].fileBody += "\t// map your database columns here\n\tfields : [\n";
                tables[tt].columns.forEach(function(c){
                    var mm = parseInt(c.Type.replace(/.*\((\d+)\).*/g,'$1'));
                    var type = /int\d+/.test(c.Type) ? typeMap['int'] : typeMap[c.Type.replace(/\([^\)]+\)/g,'')];
                    type = type === undefined ? typeMap['varchar'] : type;
                    var req = c.Null === 'NO' || c.Null == false ? true : false;

                    var props = [
                    'name : \''+c.Field+'\'',
                    'label : \''+c.Field+'\'.humanize()',
                    'type : \''+type+'\'',
                    'required : '+(!req?'false':'true')
                    ];
                    
                    if(type === typeMap['int'] && c.Field === 'id')
                        props.push('primaryKey : true');
                    if(c.length_var && c.length_var!==-1){
                        props.push('max : '+c.Length);
                    }else if(typeof mm === 'number' && !isNaN(mm)){
                        props.push('max : '+mm);
                    }
                    
                    tables[tt].fileBody += '\t\t{'+props.join(', ')+'},\n';
                });
                tables[tt].fileBody += '\t],\n'
                tables[tt].fileBody += ''
                +'\t// place your custom model methods below.\n'
                +'\tmethods : {\n'
                +"\t\t$instanceMethod : function(){ console.log('Prefix your instance methods\\' name with a dollar sign ($). Example: model.$instanceMethod()');},\n"
                +"\t\tclassMethod : function(){ console.log('This class method is accesed statically. Example: this.models.modelName.classMethod()');}\n"
                +'\t},\n'
                +'\trelations : {\n'
                +'\t\thasOne:[],\n'
                +'\t\thasMany:[],\n'
                +'\t\tbelongsTo:[],\n'
                +'\t}';
                
                var content = [
                tables[tt].fileHeader,
                tables[tt].fileBody,
                tables[tt].fileFooter
                ];
                var fname = path.resolve(__dirname+'/../../src/models/'+tt.singular().toLowerCase()+'.js');

                console.log('Saving '+tt.singular()+' model into '+fname);
                fs.writeFile(fname,content.join('\n'),function(err){
                    if (err) throw err;
                });
            }
        }, 5000);
    });
});