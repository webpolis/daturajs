var mongodb = require("mongodb");

exports.Driver = Driver;

function Driver(config, connection, opts) {
	this.config = config || {};
	this.opts   = opts || {};

	if (connection) {
		this.db = connection;
	} else {
		this.db = new mongodb.Db(
			this.config.database,
			new mongodb.Server(
				this.config.host || "localhost",
				this.config.port || 27017,
				{}
			),
			{ w: 1 }
		);
	}
}

Driver.prototype.on = function (ev, cb) {
	if (ev == "error") {
		this.db.on("error", cb);
	}
	return this;
};

Driver.prototype.connect = function (cb) {
	this.db.open(cb);
};

Driver.prototype.close = function (cb) {
	this.db.close(cb);
};

Driver.prototype.find = function (fields, table, conditions, opts, cb) {
	if (opts.merge) {
		// mongo driver uses a completely different approach than sql drivers
		var col = opts.merge.to.table;
		var extra = opts.merge.instance.store()[opts.merge.name];
		var ids = [];

		if (!Array.isArray(extra)) {
			return cb(null, []);
		}

		for (var i = 0; i < extra.length; i++) {
			ids.push(extra[i]._);
		}

		conditions = {};
		conditions[opts.merge.to.field] = ids;

		delete opts.merge;

		return this.find(fields, col, conditions, opts, cb);
	}

	this.db.collection(table, function (err, col) {
		if (err) {
			return cb(err);
		}

		var op, k;

		for (k in conditions) {
			if (!conditions.hasOwnProperty(k)) continue;

			if (conditions[k] && conditions[k]._bsontype == 'DBRef') {
				conditions[k] = conditions[k].oid;
			} else if (conditions[k].orm_special_object) {
				op = conditions[k].orm_special_object();
				switch (op) {
					case "between":
						conditions[k] = { $gte: conditions[k].from, $lte: conditions[k].to };
						break;
					case "eq":
						conditions[k] = conditions[k].val;
						break;
					case "ne":
						conditions[k] = { $ne: conditions[k].val };
						break;
					case "gt":
						conditions[k] = { $gt: conditions[k].val };
						break;
					case "gte":
						conditions[k] = { $gte: conditions[k].val };
						break;
					case "lt":
						conditions[k] = { $lt: conditions[k].val };
						break;
					case "lte":
						conditions[k] = { $lte: conditions[k].val };
						break;
				}
			} else if (Array.isArray(conditions[k])) {
				conditions[k] = { $in: conditions[k] };
			}
		}

		console.log("find()", table, conditions);
		var cursor = col.find(conditions, fields || []);

		if (opts.offset) {
			cursor.skip(opts.offset);
		}
		if (opts.limit) {
			cursor.limit(opts.limit);
		}
		if (opts.order) {
			cursor.sort([ opts.order[0], (!opts.order[1] || 'Z' ? 'descending' : 'ascending') ]);
		}

		cursor.toArray(cb);
	});
};

Driver.prototype.insert = function (table, data, cb) {
	this.db.collection(table, function (err, col) {
		if (err) {
			return cb(err);
		}

		console.log("insert()", table, data);

		col.insert(data, { safe: true }, function (err, objects) {
			if (err) {
				return cb(err);
			}

			return cb(null, {
				id: objects[0]._id
			});
		});
	});
};

Driver.prototype.update = function (table, changes, conditions, cb) {
	this.db.collection(table, function (err, col) {
		if (err) {
			return cb(err);
		}

		console.log("update()", table, changes, conditions);

		col.update(conditions, { $set: changes }, { safe: true }, cb);
	});
};

Driver.prototype.remove = function (table, conditions, cb) {
	this.db.collection(table, function (err, col) {
		if (err) {
			return cb(err);
		}

		console.log("remove()", table, conditions);

		col.remove(conditions, cb);
	});
};

Driver.prototype.removeManyAssociation = function (Instance, Association, ids, cb) {
	var changes = {}, conditions = {};

	if (ids === null) {
		changes[Association.name] = null;
		conditions[Association.myModel.id] = Instance.idValue();

		return this.update(Association.myModel.table, changes, conditions, cb);
	}

	var current_list = Instance.store()[Association.name];
	var new_list = [], found;

	if (!Array.isArray(current_list)) {
		return cb(null);
	}

	console.log(current_list[0]._.toHexString());

	for (var i = 0; i < current_list.length; i++) {
		found = false;
		for (var j = 0; j < ids.length; j++) {
			if (current_list[i]._.toHexString() == ids[j].toHexString()) {
				found = true;
				break;
			}
		}
		if (!found) {
			new_list.push(current_list[i]);
		}
	}

	console.log(current_list, new_list);

	if (current_list.length == new_list.length) {
		return cb(null);
	}

	changes[Association.name] = new_list;
	conditions[Association.myModel.id] = Instance.idValue();

	return this.update(Association.myModel.table, changes, conditions, cb);
};

Driver.prototype.clear = function (table, cb) {
	this.db.collection(table, function (err, col) {
		if (err) {
			return cb(err);
		}

		col.remove(cb);
	});
};

Driver.prototype.convertReference = function (table, id) {
	if (id === 0) {
		return null;
	}
	return new mongodb.DBRef(table, id, this.config.database);
};
